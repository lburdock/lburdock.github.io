(self.webpackChunklburdock_github_io=self.webpackChunklburdock_github_io||[]).push([[583],{7701:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},metadata:function(){return p},toc:function(){return o},default:function(){return m}});var n=a(2122),r=a(9756),s=(a(7294),a(3905)),l=["components"],i={slug:"testing-script",title:"Testing"},p={type:"mdx",permalink:"/script",source:"@site/src/pages/script.mdx"},o=[{value:"Matchers",id:"matchers",children:[{value:"Create the test file",id:"create-the-test-file",children:[]},{value:"Number matchers",id:"number-matchers",children:[]},{value:"String matchers",id:"string-matchers",children:[]},{value:"Array matcher",id:"array-matcher",children:[]},{value:"Object matcher",id:"object-matcher",children:[]},{value:"Bad data",id:"bad-data",children:[]}]},{value:"Paths",id:"paths",children:[{value:"Tests",id:"tests",children:[]}]},{value:"Mocking our own code",id:"mocking-our-own-code",children:[]},{value:"Mocking a library",id:"mocking-a-library",children:[]},{value:"Testing components",id:"testing-components",children:[{value:"Test 1: Exists",id:"test-1-exists",children:[]},{value:"Test 2: Img",id:"test-2-img",children:[]},{value:"Test 3: Input",id:"test-3-input",children:[]},{value:"Test 4: Button",id:"test-4-button",children:[]},{value:"Test 5: Edit",id:"test-5-edit",children:[]},{value:"Test 6: Cancel",id:"test-6-cancel",children:[]},{value:"Old",id:"old",children:[]}]}],u={toc:o};function m(e){var t=e.components,a=(0,r.Z)(e,l);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Today, we are going to talk about testing your code with Jest and React Testing Library."),(0,s.kt)("p",null,"The goal of testing is to verify that the logic you write returns the correct result."),(0,s.kt)("h2",{id:"matchers"},"Matchers"),(0,s.kt)("p",null,"For our first example, we have the ",(0,s.kt)("inlineCode",{parentName:"p"},"transformNum")," function which takes a number and returns an object of different data types based on that number:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The number squared"),(0,s.kt)("li",{parentName:"ul"},"A string with the number repeated"),(0,s.kt)("li",{parentName:"ul"},"An array where the length is the number")),(0,s.kt)("h3",{id:"create-the-test-file"},"Create the test file"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Create ",(0,s.kt)("inlineCode",{parentName:"p"},"transformNum.test.js"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"First, we have to import our function for testing:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import transformNum from "./transformNum";\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Jest gives us some globals we can use to organize and run our tests.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We'll use ",(0,s.kt)("inlineCode",{parentName:"p"},"describe")," to show what function we are testing"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'describe("transformNum", () => {});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"test")," will explain what this individual test is doing"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'test("returns the correct data", () => {});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Here is where we are going to write our first test, so we need to call the function"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const result = transformNum(3);\n")))),(0,s.kt)("h3",{id:"number-matchers"},"Number matchers"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Let's talk about the number portion of the result first. What we want is a way to make to make sure that ",(0,s.kt)("inlineCode",{parentName:"p"},"num")," equals 9. Or that ",(0,s.kt)("inlineCode",{parentName:"p"},"num")," is less than 10."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// result.num === 9\n// result.num < 10\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Jest gives us a nice way to do that with the expect function and matchers"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"expect(result.num).toBe(9);\nexpect(result.num).toBeLessThan(10);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"string-matchers"},"String matchers"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"There are different matchers for different data types. Say we want to test the exact string value:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(result.str).toBe("Number: 333");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Or, if we don't want to exactly match the string, we could use:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(result.str).toContain("333");\nexpect(result.str).toMatch(/number: 3/i);\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"array-matcher"},"Array matcher"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Next, we want to test the array value:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"expect(result.arr).toBe([0, 1, 2]);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--danger"},"Run Tests: Fail")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Just like ",(0,s.kt)("inlineCode",{parentName:"p"},"result.arr === [0, 1, 2]")," returns false, this will fail. We need to use deep equality:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"expect(result.arr).toEqual([0, 1, 2]);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"object-matcher"},"Object matcher"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We don't have to test the object key/values separately, Jest gives us a way to test the whole result object. It uses a different matcher:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(result).toStrictEqual({\n  num: 9,\n  str: "Number: 333",\n  arr: [0, 1, 2],\n});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"bad-data"},"Bad data"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"This function is going to throw an error if we don't pass in a number. Maybe we are okay with that, so we can write a test to verify that.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The structure of this expect argument is a little different, we have to use a callback so it can catch the error."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'test("no argument", () => {\n  expect(() => transformNum()).toThrow();\n});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Maybe we don't want an error, so we can update ",(0,s.kt)("inlineCode",{parentName:"p"},"transformNum")," to handle that case and then update our test."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="transformNum.js"',title:'"transformNum.js"'},"if (!num) return null;\n")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="transformNum.test.js"',title:'"transformNum.test.js"'},"expect(transformNum()).toBeNull();\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"These are just a few of the ",(0,s.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#methods"},"many matchers available")))),(0,s.kt)("h2",{id:"paths"},"Paths"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The key to testing a function well is making sure you write a test for every logic path.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"On that note, let's take a look at ",(0,s.kt)("inlineCode",{parentName:"p"},"getReadableNum"),". This function converts large numbers into a more readable format. It has 4 paths:"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Non-numbers return empty strings"),(0,s.kt)("li",{parentName:"ul"},"Numbers between 1 million and 1 billion"),(0,s.kt)("li",{parentName:"ul"},"Numbers between 1 thousand and 1 million"),(0,s.kt)("li",{parentName:"ul"},"Numbers under 1 thousand"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"BUT it actually has 6 paths, because ",(0,s.kt)("inlineCode",{parentName:"p"},"removeZero")," has different behavior if the number ends in a ",(0,s.kt)("inlineCode",{parentName:"p"},".0")))),(0,s.kt)("h3",{id:"tests"},"Tests"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We could write a separate test for each one of these paths, but I'm going to show you a cool iterative test instead!")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The structure of that is a little bit different:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'test.each([])("10,100,000,000 should return 10.1B", () => {\n  // test\n});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Each item in the array is going to be passed as an argument to this function, so we can unpack ",(0,s.kt)("inlineCode",{parentName:"p"},"num")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"expected")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'test.each([{ num: 10100000000, expected: "10.1B" }])(\n  "10,100,000,000 should return 10.1B",\n  ({ num, expected }) => {\n    expect(getNiceNumber(num)).toBe(expected);\n  }\n);\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"That passed so we also want to do add objects for the other paths"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'test.each([\n  { num: 10100000000, expected: "10.1B" },\n  { num: 10000000000, expected: "10B" },\n  { num: 10100000, expected: "10.1M" },\n  { num: 10000000, expected: "10M" },\n  { num: 10100, expected: "10.1K" },\n  { num: 10000, expected: "10K" },\n  { num: 999, expected: "999" },\n  { num: NaN, expected: "" },\n  { num: undefined, expected: "" },\n])("10,100,000,000 should return 10.1B", ({ num, expected }) => {\n  expect(getNiceNumber(num)).toBe(expected);\n});\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"But our helper text doesn't match what we are sending in, so lets use the text formatting option"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'"$num should return $expected";\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h2",{id:"mocking-our-own-code"},"Mocking our own code"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We are going to be testing ",(0,s.kt)("inlineCode",{parentName:"p"},"getEventStatus")," which returns a string indicating if an event is in the past or future. It uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," function to determine which text to display.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When we run the tests we can see that everything is passing. And you can see that the tests run ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Everything seems fine with this test, but after August 1st, this test will fail. We can see that if we change it to yesterday's date.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--danger"},"Run Tests: Fail")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Since our goal is to test ",(0,s.kt)("inlineCode",{parentName:"p"},"getEventStatus"),", we are going to mock ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," so we can still test both paths in ",(0,s.kt)("inlineCode",{parentName:"p"},"getEventStatus")," without worrying about the date string causing this test to fail in the future.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Mocking ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," means we replace that function with a fake function that returns what we need.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"To do that, we'll need to import ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow"),":"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import { isBeforeNow } from "./utils";\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"And we'll need to use Jest's mocking function so Jest knows to replace it with our fake function."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'jest.mock("./utils");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Then we'll tell the first test that ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," is going to return ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," because we want to test the path where the date is in the past:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"isBeforeNow.mockReturnValue(true);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"And we'll tell the second test that ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," returns false."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"isBeforeNow.mockReturnValue(false);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When we run the test, we can see that the tests are passing and we are no longer calling ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We can also verify that our date is being sent in to our mock ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow")," (like it would be for the real ",(0,s.kt)("inlineCode",{parentName:"p"},"isBeforeNow"),")."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(isBeforeNow).toHaveBeenCalledWith("2021-06-01T12:00:00.000Z");\n')))),(0,s.kt)("h2",{id:"mocking-a-library"},"Mocking a library"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The last example involved us mocking our own code, but we can also mock libraries too.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Here we have ",(0,s.kt)("inlineCode",{parentName:"p"},"getEventStatus")," which is doing the same thing as our last ",(0,s.kt)("inlineCode",{parentName:"p"},"getEventStatus"),", but it uses date-fns's ",(0,s.kt)("inlineCode",{parentName:"p"},"isBefore")," instead of our own function.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"So these tests have the same problem as before, the future date will eventually fail. So we'll mock ",(0,s.kt)("inlineCode",{parentName:"p"},"isBefore"),"!")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We'll import the function:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import isBefore from "date-fns/isBefore";\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We'll tell Jest we are mocking the function."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'jest.mock("date-fns/isBefore");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"And we'll return ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," for the first test and ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," for the second."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"isBefore.mockReturnValue(true);\n")))),(0,s.kt)("h2",{id:"testing-components"},"Testing components"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"For our last example, we'll test a react component!")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Demo the component"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"This ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," component displays a user's avatar and name.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"You can edit the username by clicking the Edit button, changing the name, and then saving")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"This is what the code looks like:"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"The wrapper has a ",(0,s.kt)("inlineCode",{parentName:"li"},"data-testid")," attribute which will come in handy"),(0,s.kt)("li",{parentName:"ul"},"The image has an alt tag that changes with the user name"),(0,s.kt)("li",{parentName:"ul"},"The username is displayed in an input element, that is disabled until the ",(0,s.kt)("inlineCode",{parentName:"li"},"Edit")," button is pressed"),(0,s.kt)("li",{parentName:"ul"},"Different buttons show in the edit state vs the display state"),(0,s.kt)("li",{parentName:"ul"},"The save button also calls the ",(0,s.kt)("inlineCode",{parentName:"li"},"onSave")," prop")))),(0,s.kt)("h3",{id:"test-1-exists"},"Test 1: Exists"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We want to write tests for this component, but Jest doesn't know what to do with React.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"This is where React Testing Library comes in! It will render the components and give us a way to query the DOM nodes for testing.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"First thing we need to do is import react and react testing library:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import React from "react";\nimport { render, screen } from "@testing-library/react";\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We'll use RTL's ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," to render the component."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"render(<User user={user} />);\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},'First thing we want to check is that component renders if we provide user data. The easiest way to do that is to ask, "Is the ',(0,s.kt)("inlineCode",{parentName:"p"},"section"),' element present in the DOM?"')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"RTL provides several ways to query the dom. For the ",(0,s.kt)("inlineCode",{parentName:"p"},"section")," element, we'll use the ",(0,s.kt)("inlineCode",{parentName:"p"},"data-testid")," attribute. We can see the DOM we've selected with ",(0,s.kt)("inlineCode",{parentName:"p"},"screen.debug"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const section = screen.getByTestId("user");\nscreen.debug(section);\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We just want to verify that it exists, so we'll use:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"expect(section).toBeInTheDocument();\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"test-2-img"},"Test 2: Img"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Now that we know it's rendering, we want to dive into the component to make sure the individual sections are correct.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We'll start with the image. We want to make sure it's using the correct alt text.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"There are a couple of options for targeting the image element, we'll start with role"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const imgByRole = screen.getByRole("img");\n// screen.debug(imgByRole);\nexpect(imgByRole).toHaveAccessibleName("First Last avatar");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"RTL provides another query that we could use here instead of this, ",(0,s.kt)("inlineCode",{parentName:"p"},"getByAltText")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'render(<User user={user} />);\nconst imgByAlt = screen.getByAltText("First Last avatar");\nexpect(imgByAlt).toBeInTheDocument();\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"You don't need both of these for this test, I just wanted to show you querying options.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"test-3-input"},"Test 3: Input"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"For the input, let's make sure that it displays the username properly"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'render(<User user={user} />);\nconst inputByRole = screen.getByRole("textbox");\nexpect(inputByRole).toHaveDisplayValue("First Last");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"There are actually a ton of other queries that you could use here instead:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const inputByLabel = screen.getByLabelText("Name:");\nexpect(inputByLabel).toHaveDisplayValue("First Last");\n\nconst inputByPlaceholder = screen.getByPlaceholderText("Enter your name");\nexpect(inputByPlaceholder).toHaveDisplayValue("First Last");\n\nconst inputByDisplayValue = screen.getByDisplayValue("First Last");\nexpect(inputByDisplayValue).toBeInTheDocument();\n\nconst inputByTitle = screen.getByTitle("User name");\nexpect(inputByTitle).toHaveDisplayValue("First Last");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"test-4-button"},"Test 4: Button"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Let's make sure the button has the correct text for the display state"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'render(<User user={user} />);\n\nconst buttonByRole = screen.getByRole("button");\nexpect(buttonByRole).toHaveTextContent("Edit");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Or, we could query by the text:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const button = screen.getByText("Edit");\nexpect(button).toBeInTheDocument();\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"test-5-edit"},"Test 5: Edit"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Let's write a test to determine if the editing capability works! We'll render the component and pass in the onSave function."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const onSave = () => {};\nrender(<User onSave={onSave} user={user} />);\n\nconst input = screen.getByRole("textbox");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"In the display state, we expect the input to be disabled"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"expect(input).toBeDisabled();\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We want to fake a click on the Edit button, so we'll import RTL's user event library:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import userEvent from "@testing-library/user-event";\n\n// ...\nuserEvent.click(screen.getByText("Edit"));\nexpect(input).toBeEnabled();\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Then we are going to clear the input and type in a new name and hit save. We want to verify that the input has the new text:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'userEvent.clear(input);\nuserEvent.type(input, "New Name");\nuserEvent.click(screen.getByText("Save"));\n\nexpect(input).toHaveDisplayValue("New Name");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We also want to verify that the ",(0,s.kt)("inlineCode",{parentName:"p"},"onSave")," function was called with the new name, but we can't do that with the empty function we passed in. Luckly, Jest provides us with a mock function that we can monitor:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const onSave = jest.fn();\n\n// ...\nexpect(onSave).toHaveBeenCalledWith("New Name");\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{className:"badge badge--success"},"Run Tests: Pass"))),(0,s.kt)("h3",{id:"test-6-cancel"},"Test 6: Cancel"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We are actually going to repeat that whole thing, except click the cancel button instead:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},'userEvent.click(screen.getByText("Cancel"));\n\nexpect(input).toHaveDisplayValue("First Last");\nexpect(onSave).not.toHaveBeenCalled();\n')))),(0,s.kt)("h3",{id:"old"},"Old"),(0,s.kt)("p",null,"For our last example, we'll write a test for a react component, using react testing library. RTL allows us to render our components and query the rendered component. We will use Jest to test for equality."),(0,s.kt)("p",null,"We have a pretty simple button component that has three states:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"default (where the button is displayed)"),(0,s.kt)("li",{parentName:"ul"},"empty (where nothing is displayed)"),(0,s.kt)("li",{parentName:"ul"},"loading (where the button is diabled)")),(0,s.kt)("p",null,"First thing we need to do is import react and react testing library:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import React from "react";\nimport { render, screen } from "@testing-library/react";\n')),(0,s.kt)("p",null,"We'll use RTL's ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," to render the component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"render(<Button>Okay</Button>);\n")),(0,s.kt)("p",null,"We'll use the ",(0,s.kt)("inlineCode",{parentName:"p"},"getByRole")," query to test that the button is there with Jest's ",(0,s.kt)("inlineCode",{parentName:"p"},"expect"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(screen.getByRole("button"));\n')),(0,s.kt)("p",null,"This query will throw an error if 0 buttons are found OR more than one buttons are found, so we could leave our test like this. But let's make sure our children text is displaying properly."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(screen.getByRole("button")).toHaveTextContent("Okay");\n')),(0,s.kt)("p",null,"If you need help debugging and what to see what RTL is rendering you can use ",(0,s.kt)("inlineCode",{parentName:"p"},"screen.debug()"),"."),(0,s.kt)("p",null,"Next, we'll check the loading state:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'render(<Button loading>Okay</Button>);\nexpect(screen.getByRole("button"));\n')),(0,s.kt)("p",null,"Run the tests. This works, but we should really test the main difference, that the button is disabled."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(screen.getByRole("button")).toBeDisabled();\n')),(0,s.kt)("p",null,"Next, we want to test the empty state."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"render(<Button empty>Okay</Button>);\n")),(0,s.kt)("p",null,"Since the ",(0,s.kt)("inlineCode",{parentName:"p"},"getByRole")," function will throw an error when no buttons are found, we have to write the test a little differently."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'expect(() => screen.getByRole("button")).toThrow();\n')))}m.isMDXComponent=!0}}]);